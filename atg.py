#!/usr/bin/env python3
#
# This Python/Tk script allows editing of data intended to be used by the
# Xilinx AXI Traffic Generator IP by generating .coe files from the input data.
#
# Copyright (C) 2018 Patricio Carr - pat@tuxengineering.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
import re
import pickle
from tkinter import *
from tkinter import messagebox
import atg_import

PROGRAM_NAME = 'AXI Traffic Generator'
MAX_ROWS = 255
VISIBLE_ROWS = 16

class Application:
    def __init__(self, root):
        self.root = root
        self.root.title(PROGRAM_NAME)
        self.init_vars()
        self.createWidgets()
        self.root.bind_all("<MouseWheel>", self.on_mousewheel)
        self.refresh_view()
        self.root.grid()
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(3, weight=1)
        self.help_text = """
        Modes: In System Init mode, only write commands will be generated by the AXI Traffic Generator (ATG), so only the address and data columns are used and exported to .coe files.\nIn Test Mode, both reads and writes are generated by the ATG, so all four .coe files are exported. \n
        Please refer to Xilinx PG125 document for details.
        """

    def init_vars(self):
        self.axi_lite_type = IntVar()
        self.radix = 'hex'
        self.scroll_offset = 0
        self.rows = []
        for i in range(MAX_ROWS):
            row = {}
            row['address'] = StringVar()
            row['data'] = StringVar()
            row['read_write'] = IntVar(value=1)
            row['mask'] = StringVar()
            row['inc_error'] = BooleanVar(value=True)
            row['goto_ok'] = IntVar(value=i+1)
            row['goto_err'] = IntVar(value=i)
            self.rows.append(row)
        self.rows[MAX_ROWS-1]['address'].set('FFFFFFFF')

    def on_read_checkbox(self, var):
        def event_handler(event):
            self.process_checkbox(var)
        return event_handler

    def process_checkbox(self, idx):
        val = self.rows[idx]['read_write'].get()
        if val == False:
            mask_var = self.rows[idx]['mask']
            mask_var.set("blah")

    def createWidgets(self):
        type_frame = Frame(self.root, height=15, bd=5, relief=GROOVE, padx=5, pady=5)
        self.gentype = Radiobutton(type_frame, \
                text="System Init (only writes)", \
                variable=self.axi_lite_type, value=0).grid(sticky=W)
        self.gentype = Radiobutton(type_frame, \
                text="Test Mode (read and writes allowed)", \
                variable=self.axi_lite_type, value=1).grid(sticky=W)
        type_frame.grid(row=0, column=0)

        # Create a frame for the canvas and scrollbar(s).
        self.data_frame = Frame(self.root, bd=2, relief=FLAT)
        self.data_frame.grid(row=3, column=0, sticky='nsew')
        # Add a canvas in that frame.
        self.data_frame.columnconfigure(0, weight=1)
        self.data_frame.rowconfigure(0, weight=1)

        # Table Frame (holds headers and rows)
        self.table_frame = Frame(self.data_frame, bd=5, relief=GROOVE)
        self.table_frame.grid(row=0, column=0, sticky='nsew')

        # Scrollbar
        self.scrollbar = Scrollbar(self.data_frame, orient=VERTICAL, command=self.on_scroll)
        self.scrollbar.grid(row=0, column=1, sticky='ns')

        headers = ["Entry", "Address", "Data", "Write", "Read", "Mask", "Count?", "Goto Ok", "Goto Error"]
        self.widths = [5, 10, 10, 5, 5, 10, 6, 8, 8]

        # Grid Headers
        for idx, text in enumerate(headers):
            Label(self.table_frame, text=text, width=self.widths[idx]).grid(row=0, column=idx)

        self.num_visible_rows = VISIBLE_ROWS
        self.data_frame.bind("<Configure>", self.on_resize)


        # Create reusable widget rows
        self.view_rows = []
        for i in range(VISIBLE_ROWS):
            row_idx = i + 1

            widgets = {}

            # Use fixed widths to align with headers approximately
            widgets['index'] = Label(self.table_frame, width=self.widths[0])
            widgets['index'].grid(row=row_idx, column=0)

            widgets['address'] = Entry(self.table_frame, width=self.widths[1])
            widgets['address'].grid(row=row_idx, column=1)

            widgets['data'] = Entry(self.table_frame, width=self.widths[2])
            widgets['data'].grid(row=row_idx, column=2)

            widgets['write_rb'] = Radiobutton(self.table_frame, value=1, width=self.widths[3]-2)
            widgets['write_rb'].grid(row=row_idx, column=3)

            widgets['read_rb'] = Radiobutton(self.table_frame, value=0, width=self.widths[4]-2)
            widgets['read_rb'].grid(row=row_idx, column=4)

            widgets['mask'] = Entry(self.table_frame, width=self.widths[5])
            widgets['mask'].grid(row=row_idx, column=5)

            widgets['inc_error'] = Checkbutton(self.table_frame, width=self.widths[6]-2)
            widgets['inc_error'].grid(row=row_idx, column=6)

            widgets['goto_ok'] = Entry(self.table_frame, width=self.widths[7])
            widgets['goto_ok'].grid(row=row_idx, column=7)

            widgets['goto_err'] = Entry(self.table_frame, width=self.widths[8])
            widgets['goto_err'].grid(row=row_idx, column=8)

            self.view_rows.append(widgets)

        buttons_frame = Frame(self.root, bd=5, relief=GROOVE, padx=5, pady=5)
        self.quitButton = Button(buttons_frame, text='Quit', command=quit)
        self.quitButton.grid(row=0, column=0, padx=20)
        self.loadButton = Button(buttons_frame, text='Load', command=self.loadFile)
        self.loadButton.grid(row=0, column=1, padx=20)
        self.saveButton = Button(buttons_frame, text='Save', command=self.saveFile)
        self.saveButton.grid(row=0, column=2, padx=20)
        self.dumpButton = Button(buttons_frame, text='Export', command=self.exportCoe)
        self.dumpButton.grid(row=0, column=3, padx=20)
        self.readButton = Button(buttons_frame, text='Import...', command=self.import_dialog)
        self.readButton.grid(row=0, column=4, padx=20)
        self.helpButton = Button(buttons_frame, text='Help', command=self.help_dialog)
        self.helpButton.grid(row=0, column=5, padx=20)
        buttons_frame.grid()


    def ensure_rows(self, count):
        current_count = len(self.view_rows)
        # Create additional rows if needed
        for i in range(current_count, count):
            row_idx = i + 1
            widgets = {}

            widgets['index'] = Label(self.table_frame, width=self.widths[0])
            widgets['index'].grid(row=row_idx, column=0)

            widgets['address'] = Entry(self.table_frame, width=self.widths[1])
            widgets['address'].grid(row=row_idx, column=1)

            widgets['data'] = Entry(self.table_frame, width=self.widths[2])
            widgets['data'].grid(row=row_idx, column=2)

            widgets['write_rb'] = Radiobutton(self.table_frame, value=1, width=self.widths[3]-2)
            widgets['write_rb'].grid(row=row_idx, column=3)

            widgets['read_rb'] = Radiobutton(self.table_frame, value=0, width=self.widths[4]-2)
            widgets['read_rb'].grid(row=row_idx, column=4)

            widgets['mask'] = Entry(self.table_frame, width=self.widths[5])
            widgets['mask'].grid(row=row_idx, column=5)

            widgets['inc_error'] = Checkbutton(self.table_frame, width=self.widths[6]-2)
            widgets['inc_error'].grid(row=row_idx, column=6)

            widgets['goto_ok'] = Entry(self.table_frame, width=self.widths[7])
            widgets['goto_ok'].grid(row=row_idx, column=7)

            widgets['goto_err'] = Entry(self.table_frame, width=self.widths[8])
            widgets['goto_err'].grid(row=row_idx, column=8)

            self.view_rows.append(widgets)

    def on_resize(self, event):
        # Approximate row height (Label/Entry + padding)
        row_height = 24
        header_height = 30

        available_height = event.height - header_height
        if available_height < 0: available_height = 0

        new_rows = available_height // row_height

        # Keep reasonable bounds
        if new_rows < 5: new_rows = 5
        if new_rows > MAX_ROWS: new_rows = MAX_ROWS

        if new_rows != self.num_visible_rows:
            self.num_visible_rows = new_rows
            self.ensure_rows(self.num_visible_rows)
            # Clamp scroll offset if we expanded
            self.scroll_offset = max(0, min(self.scroll_offset, MAX_ROWS - self.num_visible_rows))
            self.refresh_view()

    def on_scroll(self, *args):
        if args[0] == 'moveto':
            fraction = float(args[1])
            self.scroll_offset = int(fraction * MAX_ROWS)
        elif args[0] == 'scroll':
            # args[1] is count (1 or -1)
            # args[2] is units/pages
            count = int(args[1])
            self.scroll_offset += count

        # Clamp
        self.scroll_offset = max(0, min(self.scroll_offset, MAX_ROWS - self.num_visible_rows))
        self.refresh_view()

    def on_mousewheel(self, event):
        if event.delta > 0:
            self.scroll_offset -= 1
        else:
            self.scroll_offset += 1

        self.scroll_offset = max(0, min(self.scroll_offset, MAX_ROWS - self.num_visible_rows))
        self.refresh_view()

    def refresh_view(self):
        # Update scrollbar thumb
        start_frac = self.scroll_offset / MAX_ROWS
        end_frac = (self.scroll_offset + self.num_visible_rows) / MAX_ROWS
        self.scrollbar.set(start_frac, end_frac)

        # Iterate over all created view rows
        for i, widgets in enumerate(self.view_rows):
            # If within current visible count
            if i < self.num_visible_rows:
                # Ensure they are visible (in case they were hidden)
                # grid() without parameters restores previous grid settings if grid_remove was used
                for w in widgets.values():
                    w.grid()

                data_idx = self.scroll_offset + i

                if data_idx < MAX_ROWS:
                    row_data = self.rows[data_idx]

                    widgets['index'].config(text=str(data_idx))
                    widgets['address'].config(textvariable=row_data['address'])
                    widgets['data'].config(textvariable=row_data['data'])
                    widgets['mask'].config(textvariable=row_data['mask'])

                    widgets['write_rb'].config(variable=row_data['read_write'])
                    widgets['read_rb'].config(variable=row_data['read_write'])

                    widgets['inc_error'].config(variable=row_data['inc_error'])
                    widgets['goto_ok'].config(textvariable=row_data['goto_ok'])
                    widgets['goto_err'].config(textvariable=row_data['goto_err'])

                    for w in widgets.values():
                        if isinstance(w, (Entry, Radiobutton, Checkbutton, Label)):
                             w.config(state='normal')
                else:
                    # Beyond MAX_ROWS (if window is very tall)
                    for w in widgets.values():
                        if isinstance(w, (Entry, Radiobutton, Checkbutton, Label)):
                             w.config(state='disabled')
            else:
                # This row is extra (window shrank), hide it
                for w in widgets.values():
                    w.grid_remove()


    def to_hex(self, string):
        if string == '':
            string = '0'
        try:
            int_val = int(string,16)
        except:
            print ("There was a problem translating a string to hex")
            int_val = 0
        hex_str = "{0:08x}".format(int_val)
        return hex_str

    def readCoe(self, filename):
        """ Read from file into array. Get radix from file and parse vectors accordingly.
        """
        array=[]
        radix_re = re.compile(r'\d+')
        with open(filename, 'r') as f:
            for line in iter(f.readline, ''):
                if 'radix' in line:                    # Find radix literal and
                    radix = radix_re.findall(line)[0]  # Extract from returned list
                    if radix == '16':
                        self.radix = 'hex'
                    elif radix == '2':
                        self.radix = 'bin'
                    else: #radix == '10':
                        self.radix = 'dec'
                    continue
                if 'memory' in line:
                    continue
                if ';' in line[0]:         # Ignore lines with only ';'
                    continue
                if line.isspace():
                    continue
                vec = line.replace(";", "").strip()     # Remove any ';' chars
                vec = vec.replace(",", "").strip()      # Remove any ',' chars
                if self.radix == 'hex':
                    pass
                elif self.radix == 'bin':
                    vec = '{0:08x}'.format(int(vec, 2))
                elif self.radix == 'dec':
                    vec = '{0:08x}'.format(int(vec, 10))
                array.append(vec)
        return array

    def writeCoe(self, filetype, array):
        """ Write <filetype>.coe file from array content """
        with open(filetype+'.coe', 'wb') as f:
            f.write('memory_initialization_radix = 16;\n'.encode())
            f.write('memory_initialization_vector =\n'.encode())
            for row in array:
                f.write(row.encode())
                f.write('\n'.encode())
            f.write(';\n'.encode())

    def row_to_ctrl(self, row):
        """ Merge fields into control word """
        ctrl = (row['goto_ok'].get() << 8) + row['goto_err'].get()
        if row['read_write'].get() == 1:
            ctrl = ctrl + (1 << 16)
        if row['inc_error'].get() == True:
            ctrl = ctrl + (1 << 17)
        ret = "{0:08x}".format(ctrl)
        return ret

    def ctrl_to_row(self, string):
        """ Parse control string into fields dict """
        val = int(string, 16)
        row = {}
        row['goto_err'] = val & 0xFF
        row['goto_ok'] = (val >> 8) & 0xFF
        row['read_write'] = (val & 0x10000) >> 16
        row['inc_error'] = ((val & 0x20000) >> 17 == 1)
        return row

    def exportCoe(self):
        addr_db = []
        data_db = []
        mask_db = []
        ctrl_db = []
        for i, row in enumerate(self.rows):
            addr_db.append(self.to_hex(row['address'].get()))
            data_db.append(self.to_hex(row['data'].get()))
            mask_db.append(self.to_hex(row['mask'].get()))
            ctrl_db.append(self.row_to_ctrl(row))

        self.writeCoe('addr', addr_db)
        self.writeCoe('data', data_db)
        if self.axi_lite_type.get() > 0:
            self.writeCoe('mask', mask_db)
            self.writeCoe('ctrl', ctrl_db)

    def saveFile(self):
        sav = []
        sav.append(self.axi_lite_type.get())
        for i in range(MAX_ROWS):
            sav.append({ \
                    'address'   : self.rows[i]['address'].get(), \
                    'data'      : self.rows[i]['data'].get(), \
                    'read_write': self.rows[i]['read_write'].get(), \
                    'mask'      : self.rows[i]['mask'].get(), \
                    'inc_error' : self.rows[i]['inc_error'].get(), \
                    'goto_ok'   : self.rows[i]['goto_ok'].get(), \
                    'goto_err'  : self.rows[i]['goto_err'].get() \
                    } \
                    )
            with open('data.atg', 'wb') as f:
                pickle.dump(sav, f)

    def loadFile(self):
        load_ok = False
        sav = []
        with open('data.atg', 'rb') as f:
            sav = pickle.load(f)
            load_ok = True
        if load_ok:
            self.axi_lite_type.set(sav[0])
            sav.pop(0)
            for i in range(MAX_ROWS):
                self.rows[i]['address'].set(sav[i]['address'])
                self.rows[i]['data'].set(sav[i]['data'])
                self.rows[i]['read_write'].set(sav[i]['read_write'])
                self.rows[i]['mask'].set(sav[i]['mask'])
                self.rows[i]['inc_error'].set(sav[i]['inc_error'])
                self.rows[i]['goto_ok'].set(sav[i]['goto_ok'])
                self.rows[i]['goto_err'].set(sav[i]['goto_err'])

    def help_dialog(self):
        messagebox.showinfo("Help", self.help_text)

    def import_dialog(self):
        dialog = atg_import.ATG_Import(self.root, 'File import')
        if not dialog.result:
            return
        column=dialog.result['column']
        filename=dialog.result['filename']
        
        if column == 'all':
            # Import all four .coe files
            self.import_all_coe_files(filename)
        else:
            # Import single file
            array = self.readCoe(filename)
            self.import_column_data(column, array)
    
    def import_all_coe_files(self, base_path):
        """Import all .coe files from specified directory or default locations"""
        import os
        
        # Determine search directories
        search_dirs = []
        if base_path and os.path.isdir(base_path):
            # User specified a directory
            search_dirs.append(base_path)
        else:
            # Use default locations: current directory and ./coe subdirectory
            current_dir = os.getcwd()
            search_dirs.append(current_dir)
            coe_subdir = os.path.join(current_dir, 'coe')
            if os.path.isdir(coe_subdir):
                search_dirs.append(coe_subdir)
        
        # Define file mappings: column name -> possible filenames
        file_mappings = {
            'address': ['addr.coe', 'address.coe'],
            'data': ['data.coe'],
            'mask': ['mask.coe'],
            'control': ['ctrl.coe', 'control.coe']
        }
        
        imported_files = []
        missing_files = []
        
        # Try to import each file type
        for column, possible_names in file_mappings.items():
            found = False
            for search_dir in search_dirs:
                if found:
                    break
                for filename in possible_names:
                    filepath = os.path.join(search_dir, filename)
                    if os.path.isfile(filepath):
                        try:
                            array = self.readCoe(filepath)
                            self.import_column_data(column, array)
                            imported_files.append(f"{column}: {filename}")
                            found = True
                            break
                        except Exception as e:
                            print(f"Error importing {filepath}: {e}")
            
            if not found:
                missing_files.append(f"{column} ({', '.join(possible_names)})")
        
    
    def import_column_data(self, column, array):
        """Import data array into specified column"""
        i=0
        for item in array:
            if i >= MAX_ROWS:
                break
            if column == 'control':         # Special handling for Control file
                row = self.ctrl_to_row(item)
                self.rows[i]['goto_ok'].set(row['goto_ok'])
                self.rows[i]['goto_err'].set(row['goto_err'])
                self.rows[i]['inc_error'].set(row['inc_error'])
                self.rows[i]['read_write'].set(row['read_write'])
            else:
                self.rows[i][column].set(item)
            i=i+1
        
        # Refresh the view to show imported data
        self.refresh_view()

if __name__ == '__main__':
    root = Tk()
    Application(root)
    root.mainloop()
